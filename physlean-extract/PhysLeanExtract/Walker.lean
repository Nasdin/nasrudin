import Lean

/-!
# PhysLean Environment Walker

Walks the Lean environment after importing PhysLean, collecting all
theorem and definition constants. Filters out:
- Constants containing `sorry` in their proof terms
- Constants tagged as `semiformal_result`
- Internal/auxiliary constants (names starting with `_`)
- Auto-generated instances (instDecidable, instOfNat, etc.)
-/

namespace PhysLeanExtract

open Lean Meta

/-- Check if `haystack` contains `needle` as a substring. -/
private def strHas (haystack : String) (needle : String) : Bool :=
  (haystack.splitOn needle).length > 1

/-- Represents an extracted theorem from PhysLean. -/
structure ExtractedTheorem where
  /-- Fully qualified Lean name -/
  name : Name
  /-- Pretty-printed type signature -/
  typeSignature : String
  /-- Raw (unprocessed) type signature from ppExpr -/
  rawSignature : String
  /-- Whether this is a theorem (vs definition/constant) -/
  isTheorem : Bool
  /-- Doc string if available -/
  docString : Option String
  /-- Whether the signature is simple enough to re-axiomatize -/
  canReaxiomatize : Bool
  deriving Inhabited, Repr

/-- Represents an extracted type/structure from PhysLean. -/
structure ExtractedType where
  /-- Fully qualified Lean name -/
  name : Name
  /-- Kind: "structure", "inductive", "def" -/
  kind : String
  /-- Pretty-printed type signature -/
  typeSignature : String
  /-- Field names with types if structure (e.g., "fieldName : Type") -/
  fields : Array String
  /-- Doc string if available -/
  docString : Option String
  deriving Inhabited, Repr

/-- Known top-level namespaces used by PhysLean's physics content.
    PhysLean opens these via `namespace`/`open` so definitions appear
    under these prefixes rather than under `PhysLean.*`. -/
private def physLeanTopNamespaces : List String :=
  [ "PhysLean."
  , "Lorentz."
  , "LorentzGroup."
  , "SpaceTime."
  , "Electromagnetism."
  , "minkowskiMatrix."
  , "complexLorentzTensor."
  , "realLorentzTensor."
  , "Fermion."
  , "Higgs."
  , "StandardModel."
  , "CliffordAlgebra."
  ]

/-- Check if a name belongs to PhysLean (not Lean/Mathlib internals). -/
def isPhysLeanName (n : Name) : Bool :=
  let str := n.toString
  physLeanTopNamespaces.any fun pfx => str.startsWith pfx

/-- Check if a name is internal/auxiliary. -/
def isInternalName (n : Name) : Bool :=
  let str := n.toString
  strHas str "._" ||
  strHas str ".match_" ||
  strHas str ".proof_" ||
  strHas str ".rec" ||
  strHas str ".brecOn" ||
  strHas str ".below" ||
  strHas str ".casesOn" ||
  strHas str ".recOn" ||
  strHas str ".noConfusion"

/-- Check if a constant name is tagged as semiformal. -/
def isSemiformal (n : Name) : Bool :=
  let str := n.toString
  strHas str "semiformal" ||
  strHas str "Semiformal"

/-- Check if a name is an auto-generated instance we should skip. -/
def isAutoGeneratedInstance (n : Name) : Bool :=
  let str := n.toString
  strHas str "instDecidable" ||
  strHas str "instOfNat" ||
  strHas str "instHMul" ||
  strHas str "instHAdd" ||
  strHas str "instHSub" ||
  strHas str "instHDiv" ||
  strHas str "instHPow" ||
  strHas str "instBEq" ||
  strHas str "instRepr" ||
  strHas str "instInhabited" ||
  strHas str "instToString" ||
  strHas str "instHashable" ||
  strHas str "instOrd" ||
  strHas str "instLT" ||
  strHas str "instLE" ||
  strHas str "instSizeOf" ||
  strHas str ".mk" ||
  strHas str ".injEq" ||
  strHas str ".ext" && strHas str "_iff"

/-- Pretty-print an expression with PhysLean-friendly options.
    Runs inside MetaM where the environment is available. -/
def ppTypeExpr (e : Expr) : MetaM String := do
  -- Use options that produce readable output
  let opts := Options.empty
    |>.setBool `pp.fullNames false
    |>.setBool `pp.universes false
    |>.setBool `pp.notation true
  withOptions (fun _ => opts) do
    let fmt ← ppExpr e
    return toString fmt

/-- Walk the environment and extract all PhysLean theorems.
    Runs in MetaM so the environment is available for pretty-printing. -/
def walkTheorems : MetaM (Array ExtractedTheorem) := do
  let env ← getEnv
  let mut results := #[]
  for (name, ci) in env.constants.map₁.toList do
    -- Skip non-PhysLean constants
    unless isPhysLeanName name do continue
    -- Skip internal names
    if isInternalName name then continue
    -- Skip semiformal results
    if isSemiformal name then continue
    -- Skip auto-generated instances
    if isAutoGeneratedInstance name then continue

    match ci with
    | .thmInfo val =>
      -- Check for sorry in the proof value
      if val.value.hasSorry then continue
      let typeStr ← try
        ppTypeExpr val.type
      catch _ =>
        pure (toString val.type)
      -- Look up doc string
      let doc ← findDocString? env name
      results := results.push {
        name := name
        typeSignature := typeStr
        rawSignature := typeStr
        isTheorem := true
        docString := doc
        canReaxiomatize := true  -- Will be refined by TypeRewriter
      }
    | .defnInfo val =>
      let typeStr ← try
        ppTypeExpr val.type
      catch _ =>
        pure (toString val.type)
      let doc ← findDocString? env name
      results := results.push {
        name := name
        typeSignature := typeStr
        rawSignature := typeStr
        isTheorem := false
        docString := doc
        canReaxiomatize := true
      }
    | _ => pure ()

  return results

/-- Walk the environment and extract PhysLean types (structures/inductives).
    Runs in MetaM so the environment is available for pretty-printing and
    structure field lookup. -/
def walkTypes : MetaM (Array ExtractedType) := do
  let env ← getEnv
  let mut results := #[]
  for (name, ci) in env.constants.map₁.toList do
    unless isPhysLeanName name do continue
    if isInternalName name then continue
    if isAutoGeneratedInstance name then continue

    match ci with
    | .inductInfo val =>
      let typeStr ← try
        ppTypeExpr val.type
      catch _ =>
        pure (toString val.type)

      -- Look up doc string
      let doc ← findDocString? env name

      -- Extract structure fields properly
      let fields ← do
        if val.ctors.length == 1 then
          -- This might be a structure — try to get field names
          match getStructureInfo? env name with
          | some structInfo =>
            let mut fieldStrs := #[]
            for fn in structInfo.fieldNames do
              let projName := name ++ fn
              match env.find? projName with
              | some projInfo =>
                -- The projection has type `Self → FieldType` (or with implicit params).
                -- Use forallTelescopeReducing to strip leading foralls and get the return type.
                let fieldTypeStr ← try
                  forallTelescopeReducing projInfo.type fun _ body =>
                    ppTypeExpr body
                catch _ =>
                  -- Fallback: pretty-print full projection type
                  try ppTypeExpr projInfo.type
                  catch _ => pure (toString projInfo.type)
                fieldStrs := fieldStrs.push s!"{fn} : {fieldTypeStr}"
              | none =>
                fieldStrs := fieldStrs.push s!"{fn}"
            pure fieldStrs
          | none =>
            -- Not a structure, just an inductive with one constructor
            pure #[]
        else
          pure #[]

      -- Determine kind: structure vs inductive
      let kind := match getStructureInfo? env name with
        | some _ => "structure"
        | none => "inductive"

      results := results.push {
        name := name
        kind := kind
        typeSignature := typeStr
        fields := fields
        docString := doc
      }
    | _ => pure ()

  return results

end PhysLeanExtract
