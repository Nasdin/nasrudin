//! Generate standalone Lean4 files from derivation results.
//!
//! Produces `.lean` files that can be independently verified by `lake build`.
//! Format follows LEAN4-BRIDGE.md Section 5.

use crate::context::DerivationContext;
use chrono::Utc;
use nasrudin_core::{BinOp, Expr, PhysConst, UnOp};

/// Configuration for Lean file generation.
#[derive(Debug, Clone)]
pub struct LeanEmitConfig {
    /// Lean namespace for the generated theorem.
    pub namespace: String,
    /// Theorem name.
    pub theorem_name: String,
    /// Whether to import Mathlib.
    pub use_mathlib: bool,
}

impl Default for LeanEmitConfig {
    fn default() -> Self {
        Self {
            namespace: "PhysicsGenerator.Derived".into(),
            theorem_name: "rest_energy".into(),
            use_mathlib: true,
        }
    }
}

/// Generate a standalone `.lean` file from a derivation context.
pub fn emit_lean_file(ctx: &DerivationContext, config: &LeanEmitConfig) -> String {
    let mut out = String::new();

    // Imports MUST come before any other content in Lean4
    if config.use_mathlib {
        out.push_str("import Mathlib\n");
    }
    out.push_str("import PhysicsGenerator.Basic\n");
    out.push_str("import PhysicsGenerator.Generated.SpecialRelativity\n\n");

    // Header comment (after imports)
    out.push_str(&format!(
        "/-!\n# Auto-generated by nasrudin-derive\n# {}\n# Theorem: {}\n-/\n\n",
        Utc::now().format("%Y-%m-%d %H:%M:%S UTC"),
        config.theorem_name,
    ));

    // Namespace
    out.push_str(&format!("namespace {}\n\n", config.namespace));
    out.push_str("open PhysicsGenerator\n");
    out.push_str("open PhysicsGenerator.SpecialRelativity\n\n");

    // Derivation steps as comments
    out.push_str("/-! ## Derivation Steps\n");
    for (i, step) in ctx.steps().iter().enumerate() {
        out.push_str(&format!(
            "  Step {}: {} [{}]\n",
            i + 1,
            step.description,
            step.rule,
        ));
    }
    out.push_str("-/\n\n");

    // Assumptions as comments
    if !ctx.assumptions().is_empty() {
        out.push_str("/-! ## Assumptions\n");
        for (name, _expr) in ctx.assumptions() {
            out.push_str(&format!("  - {name}\n"));
        }
        out.push_str("-/\n\n");
    }

    // The theorem statement
    emit_rest_energy_theorem(&mut out, config);

    // Close namespace
    out.push_str(&format!("\nend {}\n", config.namespace));

    out
}

/// Emit the E=mc² theorem with proof.
///
/// This generates the specific theorem for rest energy.
/// Future versions will generalize to arbitrary derivation results.
fn emit_rest_energy_theorem(out: &mut String, config: &LeanEmitConfig) {
    out.push_str(&format!(
        "/-- Einstein's mass-energy equivalence: E = mc²\n    Auto-derived from mass-shell condition at rest. -/\n"
    ));
    out.push_str(&format!(
        "theorem {name} (E m : ℝ)\n",
        name = config.theorem_name
    ));
    out.push_str("    (hE : 0 ≤ E) (hm : 0 ≤ m)\n");
    out.push_str("    (h_em : E ^ 2 = (m * c ^ 2) ^ 2) :\n");
    out.push_str("    E = m * c ^ 2 := by\n");
    out.push_str("  have hmc : 0 ≤ m * c ^ 2 := by positivity\n");
    out.push_str("  have h_sqrt := congr_arg Real.sqrt h_em\n");
    out.push_str("  rwa [Real.sqrt_sq hE, Real.sqrt_sq hmc] at h_sqrt\n");
}

/// Convert an `Expr` to Lean4 term syntax.
pub fn expr_to_lean(expr: &Expr) -> String {
    match expr {
        Expr::Var(name) => name.clone(),
        Expr::Const(c) => const_to_lean(c),
        Expr::Lit(n, d) => {
            if *d == 1 {
                if *n >= 0 {
                    format!("{n}")
                } else {
                    format!("({n})")
                }
            } else {
                format!("({n} / {d})")
            }
        }
        Expr::BinOp(op, l, r) => {
            let ls = expr_to_lean(l);
            let rs = expr_to_lean(r);
            match op {
                BinOp::Add => format!("({ls} + {rs})"),
                BinOp::Sub => format!("({ls} - {rs})"),
                BinOp::Mul => format!("({ls} * {rs})"),
                BinOp::Div => format!("({ls} / {rs})"),
                BinOp::Pow => format!("({ls} ^ {rs})"),
                BinOp::Eq => format!("{ls} = {rs}"),
                BinOp::Le => format!("{ls} ≤ {rs}"),
                BinOp::Lt => format!("{ls} < {rs}"),
                BinOp::Ge => format!("{ls} ≥ {rs}"),
                BinOp::Gt => format!("{ls} > {rs}"),
                _ => format!("({ls} «{op:?}» {rs})"),
            }
        }
        Expr::UnOp(op, e) => {
            let es = expr_to_lean(e);
            match op {
                UnOp::Neg => format!("(-{es})"),
                UnOp::Sqrt => format!("Real.sqrt {es}"),
                UnOp::Abs => format!("|{es}|"),
                _ => format!("«{op:?}» {es}"),
            }
        }
        _ => format!("sorry /- {expr:?} -/"),
    }
}

fn const_to_lean(c: &PhysConst) -> String {
    match c {
        PhysConst::SpeedOfLight => "c".into(),
        PhysConst::PlanckConst => "h_planck".into(),
        PhysConst::ReducedPlanck => "hbar".into(),
        PhysConst::GravConst => "G".into(),
        PhysConst::Boltzmann => "k_B".into(),
        PhysConst::VacuumPermittivity => "eps0".into(),
        PhysConst::VacuumPermeability => "mu0".into(),
        PhysConst::Pi => "Real.pi".into(),
        PhysConst::EulersNumber => "Real.exp 1".into(),
        _ => format!("«{c:?}»"),
    }
}
