//! Proof export pipeline: Theorem → standalone `.lean` file.
//!
//! Generates self-contained Lean4 files that can be verified independently
//! by academics. Format follows LEAN4-BRIDGE.md Section 5.
//!
//! Export pipeline:
//! 1. Load theorem + proof from RocksDB
//! 2. Resolve axiom ancestors → determine required imports
//! 3. Convert Expr AST → Lean4 type signature
//! 4. Convert ProofTree → Lean4 proof body
//! 5. Emit `.lean` file with header, imports, statement, proof

use std::path::{Path, PathBuf};

use anyhow::Result;
use nasrudin_core::{Domain, Expr, ProofTree, Theorem, VerificationStatus};

use crate::lean_syntax::{
    collect_free_vars, expr_to_lean4, render_proof, resolve_imports,
};

/// Configuration for proof export.
#[derive(Debug, Clone)]
pub struct ExportConfig {
    /// Output directory for generated `.lean` files.
    pub output_dir: PathBuf,
    /// Lean4 namespace prefix.
    pub namespace: String,
    /// Whether to include Mathlib imports.
    pub use_mathlib: bool,
}

impl Default for ExportConfig {
    fn default() -> Self {
        Self {
            output_dir: PathBuf::from("prover/PhysicsGenerator/Exported"),
            namespace: "PhysicsGenerator.Exported".into(),
            use_mathlib: true,
        }
    }
}

/// A proof ready for export to Lean4.
#[derive(Debug, Clone)]
pub struct ExportableProof {
    /// Theorem name (valid Lean4 identifier).
    pub name: String,
    /// The theorem statement as an `Expr`.
    pub statement: Expr,
    /// The proof tree.
    pub proof: ProofTree,
    /// Human-readable description.
    pub description: String,
    /// Required imports (Lean module paths).
    pub imports: Vec<String>,
    /// Physics domain.
    pub domain: Domain,
    /// Hex-encoded theorem ID.
    pub theorem_id: String,
    /// Verification tactic used (if known).
    pub tactic_used: Option<String>,
}

impl ExportableProof {
    /// Create an exportable proof from a verified theorem.
    pub fn from_theorem(theorem: &Theorem) -> Option<Self> {
        let tactic_used = match &theorem.verified {
            VerificationStatus::Verified { tactic_used, .. } => Some(tactic_used.clone()),
            _ => None,
        };

        let imports = resolve_imports(&theorem.domain, &theorem.proof);
        let name = format!("auto_{}", hex::encode(theorem.id));

        Some(Self {
            name,
            statement: theorem.statement.clone(),
            proof: theorem.proof.clone(),
            description: theorem.latex.clone(),
            imports,
            domain: theorem.domain.clone(),
            theorem_id: hex::encode(theorem.id),
            tactic_used,
        })
    }
}

/// Export a proof to a standalone `.lean` file.
///
/// Returns the path to the generated file.
pub fn export_proof(proof: &ExportableProof, config: &ExportConfig) -> Result<PathBuf> {
    let content = render_lean_file(proof, config);

    let file_name = format!("{}.lean", proof.name);
    let output_path = config.output_dir.join(&file_name);

    if let Some(parent) = output_path.parent() {
        std::fs::create_dir_all(parent)?;
    }

    std::fs::write(&output_path, &content)?;
    tracing::info!("Exported proof to {}", output_path.display());

    Ok(output_path)
}

/// Render a proof to Lean4 source code.
pub fn render_lean_file(proof: &ExportableProof, config: &ExportConfig) -> String {
    let mut out = String::new();

    // Imports MUST come before any other content in Lean4
    if config.use_mathlib {
        out.push_str("import Mathlib\n");
    }
    // Domain-specific imports
    let imports = resolve_imports(&proof.domain, &proof.proof);
    for imp in &imports {
        out.push_str(&format!("import {imp}\n"));
    }
    // Additional explicit imports
    for imp in &proof.imports {
        if !imports.iter().any(|i| i == imp) {
            out.push_str(&format!("import {imp}\n"));
        }
    }
    out.push('\n');

    // Metadata header (after imports — Lean4 requires imports first)
    out.push_str(&format!(
        "/-!\n\
         # {name}\n\
         \n\
         {description}\n\
         \n\
         Auto-generated by Nasrudin\n\
         Theorem ID: {id}\n\
         Domain:     {domain:?}\n",
        name = proof.name,
        description = proof.description,
        id = proof.theorem_id,
        domain = proof.domain,
    ));
    if let Some(ref tactic) = proof.tactic_used {
        out.push_str(&format!("Tactic:     {tactic}\n"));
    }
    out.push_str(&format!(
        "\nVerify independently:\n  lake build {namespace}.{name}\n-/\n\n",
        namespace = config.namespace,
        name = proof.name,
    ));

    // Namespace
    out.push_str(&format!("namespace {}\n\n", config.namespace));
    out.push_str("open PhysicsGenerator\n");

    // Open domain-specific namespaces
    let domain_ns = domain_to_lean_namespace(&proof.domain);
    if !domain_ns.is_empty() {
        out.push_str(&format!("open {domain_ns}\n"));
    }
    out.push('\n');

    // Theorem signature + proof body
    out.push_str(&format!("/-- {} -/\n", proof.description));
    out.push_str(&render_theorem_with_proof(proof));
    out.push('\n');

    // Close namespace
    out.push_str(&format!("end {}\n", config.namespace));

    out
}

/// Render theorem statement + proof body.
fn render_theorem_with_proof(proof: &ExportableProof) -> String {
    let free_vars = collect_free_vars(&proof.statement);
    let params: Vec<&str> = free_vars
        .iter()
        .filter(|v| !is_physics_constant(v))
        .map(|v| v.as_str())
        .collect();

    let param_str = if params.is_empty() {
        String::new()
    } else {
        let vars = params.join(" ");
        format!(" ({vars} : ℝ)")
    };

    let lean_stmt = expr_to_lean4(&proof.statement);
    let proof_body = render_proof(&proof.proof);

    format!("theorem {name}{param_str} :\n    {lean_stmt}{proof_body}", name = proof.name)
}

/// Map Domain to a Lean4 namespace to `open`.
fn domain_to_lean_namespace(domain: &Domain) -> &'static str {
    match domain {
        Domain::SpecialRelativity => "PhysicsGenerator.SpecialRelativity",
        Domain::Electromagnetism => "PhysicsGenerator.Electromagnetism",
        Domain::QuantumMechanics => "PhysicsGenerator.QuantumMechanics",
        Domain::Thermodynamics => "PhysicsGenerator.Thermodynamics",
        Domain::ClassicalMechanics => "PhysicsGenerator.Mechanics",
        _ => "",
    }
}

/// Check if a variable name is a physics constant in the PhysicsGenerator namespace.
fn is_physics_constant(name: &str) -> bool {
    matches!(
        name,
        "c" | "G"
            | "h_planck"
            | "hbar"
            | "k_B"
            | "e_charge"
            | "m_e"
            | "m_p"
            | "eps0"
            | "mu0"
            | "N_A"
    )
}

/// Verify a `.lean` file by running `lake build`.
///
/// Uses the same PATH-augmented command builder as the process verifier
/// to ensure `~/.elan/bin` is on PATH.
pub fn verify_via_lake(prover_root: &Path, module_path: &str) -> Result<bool> {
    let output = crate::process::lake_command()
        .arg("build")
        .arg(module_path)
        .current_dir(prover_root)
        .output()?;

    if output.status.success() {
        tracing::info!("lake build {module_path}: OK");
        Ok(true)
    } else {
        let stderr = String::from_utf8_lossy(&output.stderr);
        tracing::error!("lake build {module_path}: FAILED\n{stderr}");
        Ok(false)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use nasrudin_core::{BinOp, FitnessScore, PhysConst, TheoremOrigin};

    #[test]
    fn export_config_default() {
        let config = ExportConfig::default();
        assert!(config.output_dir.to_str().unwrap().contains("Exported"));
        assert!(config.use_mathlib);
    }

    #[test]
    fn render_lean_file_has_imports_and_theorem() {
        let proof = ExportableProof {
            name: "test_thm".into(),
            statement: Expr::BinOp(
                BinOp::Eq,
                Box::new(Expr::Var("E".into())),
                Box::new(Expr::BinOp(
                    BinOp::Mul,
                    Box::new(Expr::Var("m".into())),
                    Box::new(Expr::BinOp(
                        BinOp::Pow,
                        Box::new(Expr::Const(PhysConst::SpeedOfLight)),
                        Box::new(Expr::Lit(2, 1)),
                    )),
                )),
            ),
            proof: ProofTree::TacticProof {
                tactic: "grind".into(),
                proof_term: vec![],
            },
            description: "E = mc^2".into(),
            imports: vec![],
            domain: Domain::SpecialRelativity,
            theorem_id: "abcdef0123456789".into(),
            tactic_used: Some("grind".into()),
        };

        let config = ExportConfig::default();
        let content = render_lean_file(&proof, &config);

        assert!(content.contains("import Mathlib"));
        assert!(content.contains("import PhysicsGenerator.Generated.SpecialRelativity"));
        assert!(content.contains("theorem test_thm"));
        assert!(content.contains("E m : ℝ"));
        assert!(content.contains("grind"));
        assert!(content.contains("Theorem ID: abcdef0123456789"));
        assert!(content.contains("Tactic:     grind"));
    }

    #[test]
    fn exportable_from_theorem() {
        let stmt = Expr::BinOp(
            BinOp::Eq,
            Box::new(Expr::Var("F".into())),
            Box::new(Expr::BinOp(
                BinOp::Mul,
                Box::new(Expr::Var("m".into())),
                Box::new(Expr::Var("a".into())),
            )),
        );
        let canonical = stmt.to_canonical();
        let id = nasrudin_core::compute_theorem_id(&canonical);
        let theorem = Theorem {
            id,
            statement: stmt,
            canonical,
            latex: "F = ma".into(),
            proof: ProofTree::TacticProof {
                tactic: "ring".into(),
                proof_term: vec![],
            },
            depth: 1,
            complexity: 5,
            domain: Domain::ClassicalMechanics,
            dimension: None,
            parents: vec![],
            children: vec![],
            verified: VerificationStatus::Verified {
                proof_term: vec![],
                tactic_used: "ring".into(),
            },
            fitness: FitnessScore::default(),
            generation: 0,
            created_at: 0,
            origin: TheoremOrigin::Axiom,
        };

        let exportable = ExportableProof::from_theorem(&theorem).unwrap();
        assert!(exportable.name.starts_with("auto_"));
        assert_eq!(exportable.tactic_used, Some("ring".into()));
    }
}
